<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>冯锌绫专属圣诞树</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; color: #ffb6c1; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        .overlay { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        .overlay h1 { margin: 0; font-size: 2rem; letter-spacing: 5px; text-shadow: 0 0 15px rgba(255,182,193,0.8); }
        .overlay p { opacity: 0.8; margin-top: 10px; font-size: 0.9rem; letter-spacing: 1px; line-height: 1.6; }

        .controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 100; align-items: center;
        }
        .btn {
            padding: 12px 24px; border-radius: 30px; border: 1px solid #ffb6c1;
            background: rgba(255, 105, 180, 0.1); color: white; cursor: pointer;
            backdrop-filter: blur(10px); transition: all 0.3s; font-weight: bold;
            text-transform: uppercase; font-size: 0.8rem; letter-spacing: 1px;
        }
        .btn:hover { background: rgba(255, 105, 180, 0.4); box-shadow: 0 0 20px rgba(255,182,193,0.4); }
        
        #photo-input { display: none; }

        #video-feed {
            position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none;
        }

        #modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(15, 15, 15, 0.98); padding: 40px; border-radius: 24px;
            border: 1px solid #ffb6c1; display: none; z-index: 1000; text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,1);
        }
        
        #loading-screen {
            position: fixed; inset: 0; background: #050505; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 1.1rem;
            letter-spacing: 2px;
        }

        .toast {
            position: fixed; top: 20px; right: 20px; padding: 15px 25px; 
            background: rgba(255, 182, 193, 0.2); border: 1px solid #ffb6c1;
            color: white; border-radius: 8px; backdrop-filter: blur(10px);
            z-index: 10000; display: none; animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-text">正在加载冯锌绫的粒子世界...</div>
    </div>

    <div id="toast" class="toast"></div>

    <div class="overlay">
        <h1>冯锌绫专属圣诞树</h1>
    </div>

    <video id="video-feed" autoplay playsinline></video>

    <div class="controls">
        <label for="photo-input" class="btn" id="upload-label">上传记忆</label>
        <input type="file" id="photo-input" accept="image/*,.heic,.heif">
        <button class="btn" id="share-btn">保存记忆</button>
    </div>

    <div id="modal">
        <h2 style="color: #ffb6c1; letter-spacing: 2px;">专属纪念碑已存至云端</h2>
        <p id="share-url" style="color: #fff; margin: 25px 0; word-break: break-all; opacity: 0.7; font-size: 0.9rem;"></p>
        <button class="btn" onclick="copyLink()">复制链接</button>
        <button class="btn" style="border-color: #444;" onclick="closeModal()">关闭</button>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- SAFEGUARD: Check if environment variables exist ---
        const hasFirebase = typeof __firebase_config !== 'undefined';
        let app, auth, db, appId;

        if (hasFirebase) {
            const firebaseConfig = JSON.parse(__firebase_config);
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'fxl-pink-xmas';
        }

        let scene, camera, renderer, treeGroup, user;
        let treeParticles, treeOrigPos, treeCurrPos, treeVels, treeScatterPos;
        let starParticles, starOrigPos, starCurrPos, starVels, starScatterPos;
        let starLight, floorParticles;
        let photoMeshes = [];
        let gifts = [];
        let teddyBear;
        
        let isHandOpen = false;
        let isPinching = false;
        let handX = 0, handY = 0;
        let prevHandX = 0;
        let treeRotationVel = 0.004;

        async function init() {
            // Only attempt Auth if Firebase is configured
            if (hasFirebase) {
                const initAuth = async () => {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                };
                try {
                    await initAuth();
                    onAuthStateChanged(auth, (u) => { 
                        user = u; 
                        if (user) checkUrlForSharedData(); 
                    });
                } catch(e) { console.warn("Firebase Auth failed"); }
            } else {
                console.log("Running in Local Mode (No Firebase)");
                document.getElementById('share-btn').style.display = 'none'; // Hide share button on local host
            }

            setupThree();
            setupHands();
            setupEvents();
            
            // Remove loading screen
            const loader = document.getElementById('loading-screen');
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 3000);
        }

        function setupThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.5, 9);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            const baseTreeCount = 35000;
            const ribbonCount = 8000;
            const bellCount = 1500;
            const totalCount = baseTreeCount + ribbonCount + bellCount;

            const treeGeo = new THREE.BufferGeometry();
            treeOrigPos = new Float32Array(totalCount * 3);
            treeCurrPos = new Float32Array(totalCount * 3);
            treeScatterPos = new Float32Array(totalCount * 3);
            treeVels = new Float32Array(totalCount * 3);
            const treeCols = new Float32Array(totalCount * 3);
            
            const foliageInner = new THREE.Color("#c71585");
            const foliageOuter = new THREE.Color("#ffb6c1");
            const trunkColor = new THREE.Color("#3e2723");
            const ribbonColor = new THREE.Color("#ffffff"); 
            const bellColor = new THREE.Color("#ffd700");   

            for(let i=0; i<totalCount; i++) {
                let x, y, z, c;
                if (i < baseTreeCount) {
                    if (Math.random() < 0.08) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * 0.28 * (1.1 - (Math.random()*0.5));
                        x = Math.cos(angle) * r; z = Math.sin(angle) * r; y = Math.random() * 2.2 - 2.0; 
                        c = trunkColor.clone().multiplyScalar(0.6 + Math.random() * 0.4);
                    } else {
                        const h = Math.random(); 
                        const heightOffset = h * 6.0 - 0.5;
                        const branchSpiral = h * Math.PI * 18;
                        const branchDir = Math.floor(Math.random() * 9) * (Math.PI * 2 / 9) + branchSpiral;
                        const maxLen = (1.1 - h) * 3.2; 
                        const reach = Math.pow(Math.random(), 0.7);
                        const droopFactor = Math.pow(reach, 1.8) * 0.7;
                        const finalR = maxLen * reach + (Math.random() - 0.5) * 0.25;
                        x = Math.cos(branchDir) * finalR; z = Math.sin(branchDir) * finalR; y = heightOffset - droopFactor;
                        c = foliageInner.clone().lerp(foliageOuter, reach);
                    }
                } else if (i < baseTreeCount + ribbonCount) {
                    const h = Math.random();
                    const angle = h * Math.PI * 12 + (Math.random() * 0.2);
                    const r = (1.1 - h) * 3.2 * 0.95;
                    x = Math.cos(angle) * r; z = Math.sin(angle) * r; y = h * 5.5 - 0.5 + Math.sin(angle * 0.5) * 0.1;
                    c = ribbonColor;
                } else {
                    const bellId = Math.floor(Math.random() * 20);
                    const bellH = (bellId / 20) * 0.8 + 0.1;
                    const bellAngle = bellId * 2.4;
                    const bellR = (1.1 - bellH) * 3.2 * 0.85;
                    const phi = Math.random() * Math.PI * 2, theta = Math.random() * Math.PI, sr = 0.12;
                    x = Math.cos(bellAngle) * bellR + Math.sin(theta) * Math.cos(phi) * sr;
                    z = Math.sin(bellAngle) * bellR + Math.sin(theta) * Math.sin(phi) * sr;
                    y = bellH * 5.5 - 0.5 + Math.cos(theta) * sr;
                    c = bellColor.clone().addScalar(Math.random() * 0.2);
                }
                treeOrigPos[i*3] = x; treeOrigPos[i*3+1] = y; treeOrigPos[i*3+2] = z;
                const sa = Math.random() * Math.PI * 2, sd = 7 + Math.random() * 7;
                treeScatterPos[i*3] = Math.cos(sa) * sd; treeScatterPos[i*3+1] = (Math.random() - 0.5) * 15; treeScatterPos[i*3+2] = Math.sin(sa) * sd;
                treeCurrPos[i*3] = x; treeCurrPos[i*3+1] = y; treeCurrPos[i*3+2] = z;
                treeCols[i*3] = c.r; treeCols[i*3+1] = c.g; treeCols[i*3+2] = c.b;
            }
            treeGeo.setAttribute('position', new THREE.BufferAttribute(treeCurrPos, 3));
            treeGeo.setAttribute('color', new THREE.BufferAttribute(treeCols, 3));
            treeParticles = new THREE.Points(treeGeo, new THREE.PointsMaterial({ size: 0.03, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.8 }));
            treeGroup.add(treeParticles);

            const starCount = 2500;
            const starGeo = new THREE.BufferGeometry();
            starOrigPos = new Float32Array(starCount * 3);
            starCurrPos = new Float32Array(starCount * 3);
            starScatterPos = new Float32Array(starCount * 3);
            starVels = new Float32Array(starCount * 3);
            const starCols = new Float32Array(starCount * 3);
            const starY = 5.6; 
            for(let i=0; i<starCount; i++) {
                const section = Math.floor(Math.random() * 10);
                const a1 = (section * Math.PI) / 5 - Math.PI/2, a2 = ((section + 1) * Math.PI) / 5 - Math.PI/2;
                const r1 = section % 2 === 0 ? 0.6 : 0.28, r2 = section % 2 === 0 ? 0.28 : 0.6;
                let u = Math.random(), v = Math.random();
                if (u + v > 1) { u = 1 - u; v = 1 - v; }
                starOrigPos[i*3] = u * Math.cos(a1) * r1 + v * Math.cos(a2) * r2;
                starOrigPos[i*3+1] = u * Math.sin(a1) * r1 + v * Math.sin(a2) * r2 + starY;
                starOrigPos[i*3+2] = (Math.random() - 0.5) * 0.2;
                const sa = Math.random() * Math.PI * 2, sd = 10 + Math.random() * 5;
                starScatterPos[i*3] = Math.cos(sa) * sd; starScatterPos[i*3+1] = 8 + (Math.random() - 0.5) * 8; starScatterPos[i*3+2] = Math.sin(sa) * sd;
                starCurrPos[i*3] = starOrigPos[i*3]; starCurrPos[i*3+1] = starOrigPos[i*3+1]; starCurrPos[i*3+2] = starOrigPos[i*3+2];
                starCols[i*3] = 1.0; starCols[i*3+1] = 0.95; starCols[i*3+2] = 0.5;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starCurrPos, 3));
            starGeo.setAttribute('color', new THREE.BufferAttribute(starCols, 3));
            starParticles = new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.045, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, opacity: 1.0 }));
            treeGroup.add(starParticles);

            starLight = new THREE.PointLight(0xffe066, 8, 20);
            starLight.position.y = starY;
            treeGroup.add(starLight);

            const fGeo = new THREE.BufferGeometry();
            const fPos = new Float32Array(5000 * 3);
            for(let i=0; i<5000; i++) {
                const a = Math.random() * Math.PI * 2, r = 4 + Math.random() * 6;
                fPos[i*3] = Math.cos(a) * r; fPos[i*3+1] = -2.25 + Math.random() * 0.15; fPos[i*3+2] = Math.sin(a) * r;
            }
            fGeo.setAttribute('position', new THREE.BufferAttribute(fPos, 3));
            floorParticles = new THREE.Points(fGeo, new THREE.PointsMaterial({ size: 0.012, color: 0xffffff, transparent: true, opacity: 0.25 }));
            treeGroup.add(floorParticles);

            createGifts();
            createTeddyBear();
            animate();
        }

        function createGifts() {
            const colors = [0xff69b4, 0xff1493, 0xffb6c1, 0xdb7093, 0xc71585];
            for(let i=0; i<6; i++) {
                const size = 0.4 + Math.random() * 0.3;
                const gift = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshStandardMaterial({ color: colors[i % colors.length], transparent: true, opacity: 1 })
                );
                const angle = (i / 6) * Math.PI * 2, dist = 1.2 + Math.random() * 0.8;
                gift.position.set(Math.cos(angle)*dist, -2.1 + size/2, Math.sin(angle)*dist);
                gift.rotation.y = Math.random() * Math.PI;
                treeGroup.add(gift);
                gifts.push(gift);
                const rib = new THREE.Mesh(new THREE.BoxGeometry(size + 0.05, size/4, size + 0.05), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 }));
                gift.add(rib);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        }

        function createTeddyBear() {
            teddyBear = new THREE.Group();
            const brown = new THREE.MeshStandardMaterial({ color: 0x8b4513, transparent: true, opacity: 1 });
            const dark = new THREE.MeshStandardMaterial({ color: 0x222222, transparent: true, opacity: 1 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), brown); body.scale.y = 1.2; teddyBear.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), brown); head.position.y = 0.5; teddyBear.add(head);
            const earL = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), brown); earL.position.set(-0.2, 0.7, 0); teddyBear.add(earL);
            const earR = earL.clone(); earR.position.set(0.2, 0.7, 0); teddyBear.add(earR);
            const limb = new THREE.SphereGeometry(0.12, 12, 12);
            const armL = new THREE.Mesh(limb, brown); armL.position.set(-0.35, 0.2, 0.1); teddyBear.add(armL);
            const armR = armL.clone(); armR.position.set(0.35, 0.2, 0.1); teddyBear.add(armR);
            const legL = new THREE.Mesh(limb, brown); legL.position.set(-0.2, -0.4, 0.2); teddyBear.add(legL);
            const legR = legL.clone(); legR.position.set(0.2, -0.4, 0.2); teddyBear.add(legR);
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), dark); eye.position.set(-0.1, 0.55, 0.25); teddyBear.add(eye);
            const eyeR = eye.clone(); eyeR.position.set(0.1, 0.55, 0.25); teddyBear.add(eyeR);
            teddyBear.position.set(1.2, -1.85, -1.2); teddyBear.rotation.y = -Math.PI / 4;
            treeGroup.add(teddyBear);
        }

        function setupHands() {
            const videoElement = document.getElementById('video-feed');
            const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.65, minTrackingConfidence: 0.65 });
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    prevHandX = handX;
                    handX = -(lm[9].x - 0.5) * 18;
                    handY = -(lm[9].y - 0.5) * 12 + 1;
                    const thumb = lm[4], index = lm[8];
                    const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                    isPinching = dist < 0.05;
                    const tips = [8, 12, 16, 20], pips = [6, 10, 14, 18];
                    let opened = 0;
                    for(let i=0; i<4; i++) { if(lm[tips[i]].y < lm[pips[i]].y) opened++; }
                    isHandOpen = opened >= 3;
                }
            });
            new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 640, height: 480 }).start()
                .catch(() => console.log("Camera access denied - falling back to passive rotation."));
        }

        function setupEvents() {
            const input = document.getElementById('photo-input');
            input.onchange = async (e) => {
                let file = e.target.files[0]; if (!file) return;
                try {
                    if (file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')) {
                        const blob = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.7 });
                        file = new File([Array.isArray(blob) ? blob[0] : blob], "mem.jpg", { type: "image/jpeg" });
                    }
                    const r = new FileReader();
                    r.onload = (ev) => addImageToScene(ev.target.result);
                    r.readAsDataURL(file);
                } catch (err) { showToast("加载出错"); }
            };
            document.getElementById('share-btn').onclick = shareScene;
        }

        function addImageToScene(url) {
            new THREE.TextureLoader().load(url, (t) => {
                const m = new THREE.MeshBasicMaterial({ map: t, side: THREE.DoubleSide, transparent: true, opacity: 0, depthWrite: false });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 1.6), m);
                const a = Math.random() * Math.PI * 2, r = 3.5 + Math.random() * 2.5;
                mesh.position.set(Math.cos(a)*r, Math.random()*5, Math.sin(a)*r);
                mesh.scale.set(0.01, 0.01, 0.01);
                mesh.lookAt(0, mesh.position.y, 0);
                treeGroup.add(mesh);
                photoMeshes.push({ mesh, data: url });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = Date.now() * 0.001;
            treeGroup.position.x += (handX - treeGroup.position.x) * 0.08;
            treeGroup.position.y += (handY - treeGroup.position.y) * 0.08;
            if (isPinching) {
                const deltaX = handX - prevHandX;
                treeRotationVel = deltaX * 0.05;
            } else {
                treeRotationVel += (0.004 - treeRotationVel) * 0.05;
            }
            treeGroup.rotation.y += treeRotationVel;
            const opTarget = isHandOpen ? 0.2 : 0.8;
            const treePAttr = treeParticles.geometry.attributes.position;
            treeParticles.material.opacity += (opTarget - treeParticles.material.opacity) * 0.04;
            for(let i=0; i<treePAttr.count; i++) {
                let ix = i*3, iy = i*3+1, iz = i*3+2;
                let tx = isHandOpen ? treeScatterPos[ix] : treeOrigPos[ix];
                let ty = isHandOpen ? treeScatterPos[iy] : treeOrigPos[iy];
                let tz = isHandOpen ? treeScatterPos[iz] : treeOrigPos[iz];
                const f = isHandOpen ? 0.02 : 0.12;
                treeVels[ix] += (tx - treeCurrPos[ix]) * f; treeVels[iy] += (ty - treeCurrPos[iy]) * f; treeVels[iz] += (tz - treeCurrPos[iz]) * f;
                treeCurrPos[ix] += treeVels[ix]; treeCurrPos[iy] += treeVels[iy]; treeCurrPos[iz] += treeVels[iz];
                treeVels[ix] *= 0.7; treeVels[iy] *= 0.7; treeVels[iz] *= 0.7;
            }
            treePAttr.needsUpdate = true;
            const starPAttr = starParticles.geometry.attributes.position;
            starParticles.material.opacity += ((isHandOpen ? 0.3 : 1.0) - starParticles.material.opacity) * 0.04;
            for(let i=0; i<starPAttr.count; i++) {
                let ix = i*3, iy = i*3+1, iz = i*3+2;
                let tx = isHandOpen ? starScatterPos[ix] : starOrigPos[ix];
                let ty = isHandOpen ? starScatterPos[iy] : starOrigPos[iy];
                let tz = isHandOpen ? starScatterPos[iz] : starOrigPos[iz];
                const f = isHandOpen ? 0.015 : 0.15;
                starVels[ix] += (tx - starCurrPos[ix]) * f; starVels[iy] += (ty - starCurrPos[iy]) * f; starVels[iz] += (tz - starCurrPos[iz]) * f;
                starCurrPos[ix] += starVels[ix]; starCurrPos[iy] += starVels[iy]; starCurrPos[iz] += starVels[iz];
                starVels[ix] *= 0.7; starVels[iy] *= 0.7; starVels[iz] *= 0.7;
            }
            starPAttr.needsUpdate = true;
            floorParticles.rotation.y += 0.001;
            floorParticles.material.opacity += (opTarget*0.3 - floorParticles.material.opacity) * 0.04;
            const physOp = isHandOpen ? 0.0 : 1.0;
            gifts.forEach((g, idx) => {
                g.material.opacity += (physOp - g.material.opacity) * 0.1;
                g.children.forEach(c => c.material.opacity = g.material.opacity);
                g.position.y += ((-2.1 + 0.25 + (isHandOpen ? 0.5 : 0)) - g.position.y) * 0.1;
                g.scale.setScalar(1 + Math.sin(t*2 + idx) * 0.05);
            });
            if(teddyBear) {
                teddyBear.traverse(n => { if(n.isMesh) n.material.opacity += (physOp - n.material.opacity) * 0.1; });
                teddyBear.position.y += ((-1.85 + (isHandOpen ? 0.3 : 0)) - teddyBear.position.y) * 0.1;
            }
            photoMeshes.forEach(p => {
                if(isHandOpen) {
                    p.mesh.scale.lerp(new THREE.Vector3(2.2, 2.2, 2.2), 0.06);
                    p.mesh.material.opacity += (1.0 - p.mesh.material.opacity) * 0.08;
                } else {
                    p.mesh.scale.lerp(new THREE.Vector3(0.01, 0.01, 0.01), 0.1);
                    p.mesh.material.opacity += (0.0 - p.mesh.material.opacity) * 0.12;
                    p.mesh.lookAt(0, p.mesh.position.y, 0);
                }
            });
            starLight.intensity = (isHandOpen ? 1.5 : 8) + Math.sin(t*4) * 3;
            renderer.render(scene, camera);
        }

        async function shareScene() {
            if (!hasFirebase || !user) {
                showToast("此模式不支持保存");
                return;
            }
            try {
                showToast("同步云端...");
                const photos = photoMeshes.map(p => ({ data: p.data }));
                const docRef = await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'shrines'), { photos, timestamp: Date.now(), owner: user.uid });
                document.getElementById('share-url').innerText = window.location.origin + window.location.pathname + "?id=" + docRef.id;
                document.getElementById('modal').style.display = 'block';
            } catch (e) { showToast("同步失败"); }
        }

        async function checkUrlForSharedData() {
            if (!hasFirebase || !user) return;
            const id = new URLSearchParams(window.location.search).get('id');
            if (id) {
                try {
                    const s = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'shrines', id));
                    if (s.exists()) s.data().photos.forEach(p => addImageToScene(p.data));
                } catch (e) {}
            }
        }

        window.copyLink = () => {
            const u = document.getElementById('share-url').innerText;
            const el = document.createElement('textarea'); el.value = u; document.body.appendChild(el);
            el.select(); document.execCommand('copy'); document.body.removeChild(el);
            showToast("已复制专属链接!");
        };
        window.closeModal = () => document.getElementById('modal').style.display = 'none';

        init();
    </script>
</body>
</html>
